%% useful condition
\newif \iftrkv@debug
\trkv@debugfalse
%% a few common variables
\newtoks \trkv@pair@kT
\newtoks \trkv@pair@vT

%% naming hint
% pairparser -- entity that assepts a whole pair  (#1<-{a=b})
% kvparser   -- splits kv pair in its args, low-level

%% name-generating macros
\def \trkv@pairparser@cs@kvparse#1{\csname trkv@pp\ex@f\@gobble\string#1@kvparse\endcsname}
\def \trkv@pairparser@cs@singular#1{\csname trkv@pp\ex@f\@gobble\string#1@singular\endcsname}
\def \trkv@pairparser@cs@list#1{\csname trkv@pp\ex@f\@gobble\string#1@listparser\endcsname}
\def \trkv@pairparser@code#1{\csname trkv@pp\ex@f\@gobble\string#1@code\endcsname}


%% real parsing

% new parser, front end
\def \trkv@pairparser@new{%
  \@ifnextchar[%]
    {\trkv@pairparser@declare}%
    {\trkv@pairparser@declare[{=}{,}]}%
}
\def \trkv@pairparser@declare[#1#2]#3{%
  \@ifnextchar[%]
    {\trkv@pairparser@def[#1#2]#3}%
    {\trkv@pairparser@def[#1#2]#3[1]}% 1 arg by default
}

% [{<tl>/pair-sep/} {<tl>/list-sep/}] {<cs>/parser name/} [<num>/number of args/] {<tl>/code/}
\def \trkv@pairparser@def[#1#2]#3[#4]#5{%
  \iftrkv@debug\trt@arg@debug{pp([#1#2]#3[#4]#5)}\fi%
  % kvparser, lowlevel one
  \trkv@kvparser@def{#1}{#3}%
  \iftrkv@debug\ex@f\ex@f\ex@f \show \trkv@pairparser@cs@kvparse{#3}\fi%
  % singular pair parser, parses a single pair
  \trkv@singularpairparser@def{#1}{#3}%
  \iftrkv@debug\ex@f\ex@f\ex@f \show \trkv@pairparser@cs@singular{#3}\fi%
  %list parser
  \ex@f\ex@f\ex@f\trkv@arglistparser@def\ex@f\ex@f\ex@f%
    {\trkv@pairparser@cs@list{#3}}%
    {#2}%
%
  \iftrkv@debug\ex@f\ex@f\ex@f \show\trkv@pairparser@cs@list{#3}\fi%
  % final user command
  \edef \trt@exphandler{
    \unexpanded{\newcommand{#3}[#4]}{%
      \def \ex@f\expandonce\ex@f{\trkv@pairparser@code{#3}{#5}}%
      \ex@f\expandonce\ex@f{\trkv@pairparser@cs@list{#3}}{%
      \ex@f\expandonce\ex@f{\trkv@pairparser@cs@singular{#3}}}%
      {#####4}%
    }%
  }\trt@exphandler%
  \iftrkv@debug\show #3\fi%
}

% {<tl>/pair-sep/} {<cs>/parser name/}
%% aaa=bbb=ccc\@nil. Called as <pair>==\@nil
%% <pair> is a=b ==> #1 <- 'a', #2 <- 'b', #3 <- '='
%% <pair> is a   ==> #1 <- 'a', #2 <- '' , #3 <- ''
\def \trkv@kvparser@def#1#2{%
  \ex@f\ex@f\ex@f \def\trkv@pairparser@cs@kvparse{#2}##1#1##2#1##3\@nil{%
    \trt@str@trim{##1}->T{\kT}%
    \trt@str@trim{##2}->T{\vT}%
  }%
}% small slowdown \iftrkv@debug \trt@arg@debug{kv:[##1]=[##2]}\fi%

% {<tl>/pair-sep/} {<cs>/parser name/} {<tl>/code/}
\def \trkv@singularpairparser@def#1#2{%
  \ex@f\ex@f\ex@f \def\trkv@pairparser@cs@singular{#2}##1{%
    \if\relax\detokenize{##1}\noexpand\relax%
      \PackageError{trkv}{\string\trkv@pair@parse Nothing to parse}%
        {Provide a nonempty string. Or invent a workaround}%
    \else%
    \begingroup%
      % holders of key and value
      \let\kT\trkv@pair@kT%
      \let\vT\trkv@pair@vT%
      \trkv@pairparser@cs@kvparse{#2}##1#1#1\@nil%
      \def\k{\the\kT}%
      \def\v{\the\vT}%
      \trkv@pairparser@code{#2}% <-- user code
    \endgroup%
    \fi%
  }%
}

% vim: ft=plaintex
