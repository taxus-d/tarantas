\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{tropt}[2017/08/05 
  Class/package option parser for `tarantas' bundle]

\RequirePackage{trkv}

\def\@xprocess@ptions{%
  \ifx\@currext\@clsextension\else
  \newPairsParser{\tro@procClsOptions}{
    \edef \CurrentOption{\k}
    \edef \CurrentValue{\v}
    \smuggle \CurrentOption \smuggle \CurrentValue
    \endgroup
    \ifx\CurrentOption\@empty%
    \else
      \@expandtwoargs\in@{,\CurrentOption,}{,\@declaredoptions,}%
      \ifin@
        \@use@ption
        \expandafter\let\csname ds@\CurrentOption\endcsname\@empty
      \fi
    \fi
    \begingroup% to pair inner \endgroup
  }%
  \ex@f\tro@procClsOptions\ex@f{\@classoptionslist}
  \fi%
  \@process@pti@ns%
}
\@onlypreamble\@xprocess@ptions
\def\@process@pti@ns{%
  \newPairsParser{\tro@procOptions}{
    \edef \CurrentOption{\k}
    \edef \CurrentValue{\v}
    \smuggle \CurrentOption \smuggle \CurrentValue
    \endgroup
    \@ifundefined{ds@\CurrentOption}
      {\@use@ption \default@ds}%
      \@use@ption%
    \begingroup% to pair inner \endgroup
  }%
  \ex@f\tro@procOptions\ex@f{\@curroptions}
  \@for\CurrentOption:=\@declaredoptions\do{%
  \expandafter\let\csname ds@\CurrentOption\endcsname\relax}%
  \let\CurrentOption\@empty
  \let\CurrentValue\@empty
  \let\@fileswith@pti@ns\@@fileswith@pti@ns
  \AtEndOfPackage{\let\@unprocessedoptions\relax}
}

\DeclareOption{togl}{
  \let\tro@bl@new\providetoggle
  \let\tro@bl@true\toggletrue
  \let\tro@bl@false\togglefalse
  \let\tro@bl@if\iftoggle
}
% namespace hint:
% tro @         tarantas options stuff
%     @ bl      well, it's kind of boolean
% will cause a trouble, surely
%     @ hnd     option handler
%     @ tmp     temporary routines
\DeclareOption{bool}{
  \let\tro@bl@new\providebool
  \let\tro@bl@true\booltrue
  \let\tro@bl@false\boolfalse
  \let\tro@bl@if\ifbool
}
\listdef \tro@list@true{true,on}
\listdef \tro@list@false{false,off}

%% Fallback                                  
\DeclareOption*{
  \PackageError{trcophand}{does not know about `\CurrentOption'.
  Please, clarify your intentions.}
}
\ExecuteOptions{togl}
\ProcessOptions*\relax


% self-made hooks
\newcommand*{\AfterOptsProcd  } {}
\newcommand*{\AfterLoadedClass} {}
% feel myself like a mountain climber

% redefined command with hooks
\newcommand*{\ProcOpts        } {
  \ProcessOptions*
  \AfterOptsProcd 
}
% another one. May limit some functionality
%+ But looks like everything still works
\newcommand{\LoadCls}[2][\relax]{
  \ifx #1\relax \LoadClass{#2}
  \else         \LoadClass[#1]{#2}
  \fi
  \AfterLoadedClass
}

% custom option handler builder
% before `do'ing stuff performs an optional check
% see below for meaningful example
\providetoggle{tro@accept}
\newcommand{\tro@hnd@new}[3][\relax]{
  \gdef#2##1{
    \ifx #1\relax \toggletrue{tro@accept}
    \else #1 
    \fi
    \iftoggle{tro@accept} {
      \def\do####1{
        \def\@opt{####1}
        #3
      }
      \docsvlist{##1}
    }\relax
  }
}

\def \tro@defhelper@flagopt#1#2#3{
  \ifblank{#1}{#2{#1}}
  {
    \ex@f\ifinlist\ex@f{\CurrentValue}{\tro@list@true}
    {#2{#1}}
    { \ex@f\ifinlist\ex@f{\CurrentValue}{\tro@list@false}
        {#3{#1}} 
        {\PackageError{tropt}
          { `\CurrentValue' is not a valid boolean value}
          {
            Should be empty, or one of 
            |\tro@list@true\tro@list@false
          }
}}}}

% #1 -- string
% #2 -- prefix
% #3 -- toks to spoil
\def \trt@prefix@rm#1#2->T#3{%
  \begingroup%
  \def\procbeg#2##1\@nil{\endgroup #3={##1}}%
  \procbeg#1\@nil%
}
\tro@hnd@new{\DeclFlagOpt}{
  \tro@bl@new{\@opt}
  \DeclareOption{\@opt}{
    \tro@defhelper@flagopt{\CurrentOption}{\tro@bl@true}{\tro@bl@false}
  }
  \DeclareOption{no\@opt}{
    \ex@f\trt@prefix@rm\ex@f{\CurrentOption}{no}->T{\toks@}
    \tro@defhelper@flagopt{\the\toks@}{\tro@bl@false}{\tro@bl@true}
    \toks@={}
  }
}

% require \@baseclass variable in the outer scope
\tro@hnd@new
[\ifundef{\@baseclass}
  {\togglefalse{tro@accept}\PackageError{tropt}%
    {\noexpand\DeclPassOpt needs to know \noexpand\@baseclass}
    {Maybe you forgot to declare it in your .cls file?}
  } {\toggletrue{tro@accept}}
]
{\DeclPassOpt}
{\DeclareOption {\@opt}
  {\PassOptionsToClass{\CurrentOption}{\@baseclass}}
} 
% as you see, lisp style can handle lots of braces gracefully
% if there is ONE command. In lisp you have (progn..) in other case 
% here, we need to suffer aestetically anyway


% to reduce `expandafter's
\def\tro@tmp@ex#1{
  \apptocmd{\AfterLoadedClass}%
  {\HasFlag{#1}{\RequirePackage{#1}}}{}{}%braces, you are hidden now
}
% there should be a workaround to conditional package loading
% looks like i have found it
\tro@hnd@new{\DeclPackOpt}{
  \ex@f\tro@bl@new\ex@f{\@opt} % like a flag
  \let\tro@olddo=\do% docsvloop inside spoils everything
  \ex@f\DeclFlagOpt\ex@f{\@opt}
  \let\do=\tro@olddo
  \ex@f\tro@tmp@ex\ex@f{\@opt}
}

% with braces
% \HasFlag{flagname}{if-present}
\newcommand{\HasFlag}[2]{%
  \tro@bl@if{#1}{#2}\relax%
}
% with else clause
\newcommand{\SwitchFlag}[3]{%
  \tro@bl@if{#1}{#2}{#3}%
}

% plain tex variation, for special occasions
% need bit of tex argument parsing here
% less `{'/`}' -> less forgotten ones
% \long\def\hasflag#1\then #2\done{
%   \tro@bl@if{#1}{#2}{}
% }
%
% should be \newif -- don't think this is useful enough.
% but can implement if anyone wishes

\endinput
