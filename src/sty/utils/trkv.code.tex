%% `variables'
\def \@trkv@pair@sep{}
\def \@trkv@prefix{}

%% `functions'

%%% setting variables
\catcode`\|=3
\def \trkv@prefix@set#1{\edef\@trkv@prefix{\detokenize{#1}}}
\def \trkv@prefix@stack{}
\def \trkv@prefix@push{%
  \ifblank{\@trkv@prefix}%
    {}%
    {\epreto\trkv@prefix@stack{\@trkv@prefix|}}%
}
\def \trkv@prefix@pop{%
  \begingroup%
  \def\proc##1|##2\@nil{%
    \endgroup%
    \trkv@prefix@set{##1}%
    \def\trkv@prefix@stack{##2}%
  }%
  \ex@f\proc\trkv@prefix@stack\@nil%
}
\catcode`\|=12
\def \trkv@pair@sepset#1{\def\@trkv@pair@sep{#1} \trkv@kvparser@init}


%% naming hint
% pairparser -- entity that assepts a pair as whole (#1={a=b})
% kvparser   -- splits kv pair in its args, low-level

%%% real parsing
% wrapper around \def to reduce expandafter's
% in defining macro with macro in arglist
% #1 -- pair separator
% #2 -- macro name
\def \trkv@kvparser@withsepdef#1#{%
  \def\trkv@kvparse##1#1##2#1##3\@nil%
}

\def \trkv@kvparser@init{%
% parsing routine
% definition is here to handle separator change
  \ex@f\trkv@kvparser@withsepdef\@trkv@pair@sep{%
    % heavy usage of token lists
    %+ as a placeholders for stripped strings
    % may be reduced
    \trt@str@trim{##1}->T{\kT}%
    % same with value
    \trt@str@trim{##2}->T{\vT}%
  }%
}

\def \trkv@kvparser@withsepuse#1#2{%
  \trkv@kvparse#2#1#1\@nil%
}

\newtoks \trkv@pair@kT
\newtoks \trkv@pair@vT

%  #1 -- pair, like {alpha=beta}
%  #2 -- what to get, like \k:\v
\def \trkv@pair@parse#1#2{%
  \if\relax\detokenize{#1}\relax%
  \PackageError{trkv}{\noexpand\trkv@pair@parse Nothing to parse}%
  {Provide a nonempty string. Or invent a workaround}%
  \else%
  \begingroup%
    % holders of key and value
    \let\kT\trkv@pair@kT%
    \let\vT\trkv@pair@vT%
    \ex@f\trkv@kvparser@withsepuse\ex@f{\@trkv@pair@sep}{#1}%
    \def\k{\the\kT}%
    \def\v{\the\vT}%
    #2% <-- user code
  \endgroup%
  \fi%
}


% new pair parser
% #1 -- name
% #2 -- expr
% \def\trkv@pairparser@def#1#2{%
%   \def#1##1##2{\trkv@pair@parse{##2}{#2}}%
% }

\newcommand*{\trkv@pairparser@def}[1]{%
  \@ifnextchar[{\trkv@pairparser@def@i{#1}}{\trkv@pairparser@def@i{#1}[{1}]}%
}

\def\trkv@pairparser@def@i#1[#2]#3{%
  \newcommand*{#1}[#2]{\trkv@pair@parse{###2}{#3}}
}


\def\trkv@epairparser@def#1#2{%
  \def#1##1{%
    \trt@macro@fullexpand{##1}->T{\toks@}%
    \ex@f\trkv@pair@parse\ex@f{\the\toks@}{#2}%
  }%
}


\def\trkv@pairsparser@def#1#2{%
  \def#1##1{%
    \def\do####1{\trkv@pair@parse{####1}{#2}}%
    \dokvlist{##1}%
  }%
}

\def\trkv@epairsparser@def#1#2{%
  \def#1##1{%
    \trt@macro@fullexpand{##1}->T{\toks@}%
    \def\do####1{\trkv@pair@parse{####1}{#2}}%
    \ex@f\dokvlist\ex@f{\the\toks@}%
  }%
}

% #1-#4 --- parser names
% #5 --- code
\def \trkv@fullpairparser@def#1#2#3#4#5{
  \trkv@pairparser@def{#1}{#5}
  \trkv@pairsparser@def{#2}{#5}
  \trkv@epairparser@def{#3}{#5}
  \trkv@epairsparser@def{#4}{#5}
}

\def \trkv@list@nospacetrim{%
\patchcmd{\etb@listitem}{\@firstofone}{\trt@empty}{}{}
}

\def \trkv@list@sepset#1{%
  \let \trt@etblistitem@old=\etb@listitem%
  \trkv@list@nospacetrim%
  \let \dokvlist=\relax 
  \let \forkvlist=\relax
  \DeclareListParser{\dokvlist}{#1}%
  \DeclareListParser*{\forkvlist}{#1}%
  \let \etb@listitem=\trt@etblistitem@old%
}

% vim: ft=plaintex
